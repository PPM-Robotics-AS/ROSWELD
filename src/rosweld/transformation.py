"""
ROSWELD
Version 0.0.1, March 2019
http://rosin-project.eu/ftp/rosweld

Copyright (c) 2019 PPM Robotics AS

This library is part of ROSWELD project,
the Focused Technical Project ROSWELD - ROS based framework
for planning, monitoring and control of multi-pass robot welding
is co-financed by the EU project ROSIN (www.rosin-project.eu)
and ROS-Industrial initiative (www.rosindustrial.eu).

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import numpy as np
from geometry_msgs.msg import Pose, Quaternion
from tf.transformations import (quaternion_from_euler,
                                quaternion_from_matrix, quaternion_matrix,
                                quaternion_multiply, translation_from_matrix,
                                translation_matrix)

from src.rosweld.point import Point


def change_basis(A, B, C):
    """Calculates the transformation needed to transform a triangle given by three points.
    The triangle lays on the xy plane. CA vector is the x axis, and CB defines the direction
    of y. The z axis is generated by the right hand rule.

    The algorithm and naming convention is based on the document
    "TPK 4170 - CAD to Fixture.doc".

    Arguments:
        A {nparray} -- Vector 1
        B {nparray} -- Vector 2
        C {nparray} -- Vector 3

    Returns:
        nparray -- NSA transformation matrix
    """

    # x axis remains the same
    n = np.subtract(A, C)
    # y axis is the CB vector, might not be orthogonal to n
    s = np.subtract(B, C)
    # generated z axis, orthogonal to n and s.
    a = np.cross(n, s)
    s = np.cross(a, n)
    # regeneration of the y axis, to assure the orthogonality.
    n = normalized(n)
    s = normalized(s)
    a = normalized(a)

    k = np.array([np.dot(n, B), np.dot(s, C), np.dot(a, A), 1.])
    T = np.array(
        [
            [n[0], s[0], a[0], 0.],
            [n[1], s[1], a[1], 0.],
            [n[2], s[2], a[2], 0.],
            [0., 0., 0., 1.]
        ])

    d = np.dot(T, k)
    return np.array(
        [
            [n[0], s[0], a[0], d[0]],
            [n[1], s[1], a[1], d[1]],
            [n[2], s[2], a[2], d[2]],
            [0., 0., 0., 1.]
        ])


def change_basis_method(pair1, pair2, pair3):
    """Calculates the transformation needed to transform T1(A1B1C1) triangle 
    to its isometric counterpart T2(A2B2C2).
    T1-to-base and T2-to-base transformations are calculated with the 
    ChangeBasisMethod. To get the transformation T1-to-T2 T1-to-base has 
    to be inverted and multiplied by T2-to-base

    Arguments:
        pair1 {tuple} -- Model-World pairs for Point1
        pair2 {tuple} -- Model-World pairs for Point2
        pair3 {tuple} -- Model-World pairs for Point3

    Returns:
        nparray -- Transformation matrix
    """

    Tbase1 = change_basis(pair1[0], pair2[0], pair3[0])
    Tbase1 = np.linalg.inv(Tbase1)
    Tbase2 = change_basis(pair1[1], pair2[1], pair3[1])
    return np.dot(Tbase2, Tbase1)


def wellness(model):
    """Calculate wellness value

    Arguments:
        model {array} -- Model points to define a triangle

    Returns:
        float -- wellness value
    """

    a = np.subtract(model[0], model[1])
    b = np.subtract(model[0], model[2])
    c = np.cross(a, b)

    #def sqeuclidean(x): return np.inner(x, x)

    return pow(np.inner(c, c), 0.25)


def recover_homogenous_affine_transformation(model, robot):
    """Create transformation matrix for the given model and robot points

    Arguments:
        model {Point[]} -- Model points
        robot {Point[]} -- Robot points

    Returns:
        nparray -- Transformation matrix
    """

    M = np.array([[0., 0., 0., 0.], [0., 0., 0., 0.],
                  [0., 0., 0., 0.], [0., 0., 0., 0.]])

    T = change_basis_method(
        (model[0], robot[0]), (model[1], robot[1]), (model[2], robot[2]))
    rot = quaternion_from_matrix(T)
    tr = translation_from_matrix(T)

    wSum = wellness(model)
    for i in range(4):
        for j in range(4):
            M[i][j] = M[i][j] + wSum * (rot[i] * rot[j])

    w, v = np.linalg.eig(M)
    q = v[:, np.argmax(w)]
    Tavg = quaternion_matrix(q)
    Ttr = translation_matrix(tr)
    Tavg = np.dot(Ttr, Tavg)

    return Tavg


def normalized(a, axis=-1, order=2):
    """Normalize a vector

    Arguments:
        a {nparray} -- vector to normalize

    Keyword Arguments:
        axis {int} -- axis (default: {-1})
        order {int} -- order (default: {2})

    Returns:
        nparray -- normalized vector
    """

    l2 = np.atleast_1d(np.linalg.norm(a, order, axis))
    l2[l2 == 0] = 1
    return (a / np.expand_dims(l2, axis))[0]


def x_zto_transformation(t, a):
    """Generate Transformation matrix for rotation

    Arguments:
        t {nparray} -- X axis
        a {nparray} -- normal
    """

    t = normalized(t)
    a = normalized(a)
    s = normalized(np.cross(a, t))
    n = normalized(np.cross(s, a))

    # generate m rotation matrix using: n, s, a
    m = np.array([
        np.append(n, 0.),
        np.append(s, 0.),
        np.append(a, 0.),
        (0, 0, 0, 1)]).transpose()

    return m


class Transformation(object):
    """Transformation class to handle the real world - model space conversion
        object {Object} -- base class
    """

    @staticmethod
    def apply_pose(obj, direction, normal, transformation, angle):
        """Apply transformation to pose

        Arguments:
            obj {geometry_msgs/Pose} -- pose in model coordinates and orientation
            direction {nparray} -- direction vector
            normal {nparray} -- normal vector
            transformation {nparray} -- 4x4 Transformation matrix

        Returns:
            geometry_msgs/Pose -- pose in robot coordinates
        """

        pose = Pose()
        pose.position = Transformation.apply_point(obj, transformation)
        pose.orientation = Transformation.apply_orientation(
            direction, normal, transformation, angle)

        return pose

    @staticmethod
    def apply_orientation(direction, normal, transformation, angle):
        """Apply the transformation to the orientation

        Arguments:
            direction {nparray} -- direction vector
            normal {nparray} -- normal vector
            transformation {nparray} -- 4x4 transformation matrix

        Returns:
            geometry_msgs/Quaternion -- new orientation
        """

        x = np.dot(transformation, np.array([direction[0], direction[1], direction[2], 1.]))[:3]
        z = np.dot(transformation, np.array(np.append(normal, 1.)))[:3]
        o = np.dot(transformation, np.array([0., 0., 0., 1.]))[:3]

        T = x_zto_transformation(
            np.subtract(x, o),
            np.subtract(z, o))

        qrot = quaternion_from_euler(angle, 0, 0)
        q = quaternion_from_matrix(T)
        q = quaternion_multiply(q, qrot)

        return Quaternion(x=q[0], y=q[1], z=q[2], w=q[3])

    @staticmethod
    def apply_point(obj, transformation):
        """Apply a transformation to a point

        Arguments:
            obj {Point} -- Model coordinates
            transformation {numpy.ndarray} -- 4x4 Transformation matrix
        """

        _p = np.append(np.array(obj[:3]), 1.)
        tf_p = np.dot(transformation, _p)
        return Point(tf_p[0], tf_p[1], tf_p[2])

    @staticmethod
    def apply_path(poses, transformation,
                   offset=np.array([0, 0, 0, 0]), angle=0):
        """Apply a transformation to points

        Arguments:
            poses {Point[]} -- Point list which we want to translate to real world coordinates
            transformation {numpy.ndarray} -- 4x4 Transformation matrix

        Returns:
            Point[] -- Real world coordinates
        """

        tf_path = []

        for i, pose in enumerate(poses):
            p = pose
            p2 = Transformation.__next_pose(poses, i)
            direction = np.subtract(np.array(p2[:3]), np.array(p[:3]))
            _pose = Transformation.apply_pose(
                pose, direction, pose[3:], transformation, angle)

            if offset is not np.zeros(4):
                # P' = F+(R*(P-F))
                _offset = np.dot(
                    quaternion_matrix(
                        np.array(
                            [
                                _pose.orientation.x,
                                _pose.orientation.y,
                                _pose.orientation.z,
                                _pose.orientation.w])),
                    offset)

                # apply the offse to the position
                _pose.position.x -= _offset[0]
                _pose.position.y -= _offset[1]
                _pose.position.z -= _offset[2]

            tf_path.append(_pose)

        return tf_path

    @staticmethod
    def rotate(pose, angle=np.zeros(3)):
        """Rotate pose with an angle

        Arguments:
            pose {geometry_msgs/Pose} -- pose to add offset
            angle {float} -- rotation angle in radians

        Returns:
            geometry_msgs/Pose -- the rotated pose
        """
        qrot = quaternion_from_euler(angle[0], angle[1], angle[2])
        q = np.array([pose.orientation.x, pose.orientation.y,
                      pose.orientation.z, pose.orientation.w])
        q = quaternion_multiply(q, qrot)

        pose.orientation = Quaternion(x=q[0], y=q[1], z=q[2], w=q[3])
        return pose

    @staticmethod
    def offset(pose, offset):
        """Add offset to pose

        Arguments:
            pose {geometry_msgs/Pose} -- pose to add offset
            offset {nparray} -- offset as a vector

        Returns:
            geometry_msgs/Pose -- the offsetted pose
        """

        if offset is not np.zeros(4):
            # P' = F+(R*(P-F))
            _offset = np.dot(
                quaternion_matrix(
                    np.array(
                        [
                            pose.orientation.x,
                            pose.orientation.y,
                            pose.orientation.z,
                            pose.orientation.w])),
                offset)

            # apply the offse to the position
            pose.position.x -= _offset[0]
            pose.position.y -= _offset[1]
            pose.position.z -= _offset[2]

        return pose

    @staticmethod
    def __pose_to_point(pose):
        """Convert pose to point

        Arguments:
            pose {geometry_msgs/Pose} -- Pose

        Returns:
            geometry_msgs/Point -- Point
        """

        return Point(pose.position.x, pose.position.y, pose.position.z)

    @staticmethod
    def __next_pose(poses, i):
        """Get next pose in poses list

        Arguments:
            poses {Pose[]} -- poses
            i {int} -- index

        Returns:
            Pose -- i+1 / i-1 pose
        """

        if i != len(poses) - 1:
            return np.array(poses[i + 1][:3])

        prev = poses[i - 1]
        return np.add(poses[i][:3], np.subtract(poses[i][:3], prev[:3]))

    @staticmethod
    def get_transformation_matrix(poses):
        """Calculates the transformation matrix from the given points

        Arguments:
            model {Point[]} -- Model space calibration point list
            measured {Point[]} -- Real world measurements

        Returns:
            numpy.ndarray -- Transformation matrix
        """

        if len(poses) == 0:
            return np.identity(4)
        elif len(poses) < 3:
            avg = Point(0, 0, 0)
            for pose in poses:
                pm = Point(pose.model.x, pose.model.y, pose.model.z)
                pr = Transformation.__pose_to_point(pose.measured)
                avg += pm - pr
            avg /= len(poses)
            return np.array((
                [1., 0., 0., avg.x],
                [0., 1., 0., avg.y],
                [0., 0., 1., avg.z],
                [0., 0., 0., 1.]))
                
        p_model = []
        p_measured = []

        for p in poses[:3]:
            p_model.append((p.model.x, p.model.y, p.model.z))
            p_measured.append(
                (p.measured.position.x,
                    p.measured.position.y,
                    p.measured.position.z))

        tf = recover_homogenous_affine_transformation(p_model, p_measured)

        return tf
